# -*- coding: utf-8 -*-
"""Desafio Final: Previsão de Doenças Cardíacas - Bertha Lutz

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tbYfU6v6nj1Q1mdymcqvD9g1w1BOXtIj

# <font color=purple size=10>Desafio Final: Previsão de Doenças Cardíacas</font>
***

<font color=purple size=5>Squad Bertha Lutz</font>

# <font color=purple size=5>Importando as bibliotecas
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.api as sm

from sklearn import  linear_model 
from sklearn.model_selection import train_test_split 
from sklearn.feature_selection import RFE
from operator import itemgetter
from scipy.stats import ttest_ind,f_oneway, skewnorm
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report, roc_curve, roc_auc_score

sns.set_style("whitegrid")
sns.set_palette("muted")

from google.colab import drive
drive.mount('/content/drive')

"""# <font color=purple size=5>Importando data set


"""

df = pd.read_csv("/content/drive/MyDrive/Heart_disease_statlog.csv")

df.head()

"""### Transformando variáveis categóricas em Object """

df[['sex','cp','fbs','restecg','exang','slope','ca','thal']] = df[['sex','cp','fbs','restecg','exang','slope','ca','thal']].astype(object)

df.info()

"""**<font color=purple size=5> Análise exploratória dos dados**

##<font color=purple size=5> 1 - Entenda a distribuição de variáveis
"""

df.head(10)

"""**Análise por idade**"""

fig, ax =plt.subplots(1,2)
sns.set(rc={'figure.figsize':(11.7,8.27)})
sns.histplot(data=df, x="age", element="step", ax = ax[0]).set_title("Histograma Idade")
sns.boxplot( y="age", data=df, ax= ax[1]).set_title("Boxplot Idade")

"""**Observações**: A idade segue uma distribuição normal, levemente assímetrica à esquerda."""

g = sns.catplot(data=df, x="sex", y="target", kind="bar")
g.fig.suptitle("Comparação de sexo pela presença ou não de doença cardíaca",  y=1.05)
g.fig.set_size_inches(7, 5)
plt.show()

"""**Tipo de dor torácica sentida pelo paciente**"""

g = sns.catplot(data=df, x="cp", y="target", kind="bar")
g.fig.suptitle("Comparação do tipo de dor torácica pela presença ou não de doença cardíaca",  y=1.05)
g.fig.set_size_inches(7, 5)
plt.show()

"""**Nível de pressão arterial do paciente no modo de repouso em mm/HG**"""

fig, ax =plt.subplots(1,2)
sns.set(rc={'figure.figsize':(11.7,8.27)})
sns.histplot(data=df, x="trestbps", element="step", ax = ax[0]).set_title("Histograma Pressão Arterial (em Repouso)")
sns.boxplot( y="trestbps", data=df, ax= ax[1]).set_title("Boxplot Pressão Arterial (em Repouso)")

"""**Colesterol sérico em mg/dl**"""

fig, ax =plt.subplots(1,2)
sns.set(rc={'figure.figsize':(11.7,8.27)})
sns.histplot(data=df, x="chol", element="step", ax = ax[0]).set_title("Histograma Colesterol Sérico")
sns.boxplot( y="chol", data=df, ax= ax[1]).set_title("Boxplot Colesterol Sérico")

"""**Níveis de açúcar no sangue em jejum > 120 mg/dl** 

"""

g = sns.catplot(data=df, x="fbs", y="target", kind="bar")
g.fig.suptitle("Níveis de açúcar no sangue pela presença ou não de doença cardíaca",  y=1.05)
g.fig.set_size_inches(7, 5)
plt.show()

"""**Resultado do eletrocardiograma em repouso**

"""

sns.catplot(data=df, x="restecg", y="target", kind="bar")
g.fig.suptitle("Eletrocardiograma em repouso pela presença ou não de doença cardíaca",  y=1.05)
g.fig.set_size_inches(7, 5)
plt.show()

"""**Frequência cardíaca máxima alcançada**"""

fig, ax =plt.subplots(1,2)
sns.set(rc={'figure.figsize':(11.7,8.27)})
sns.histplot(data=df, x="thalach", element="step", ax = ax[0]).set_title("Histograma Frequência Cardíaca Máxima")
sns.boxplot( y="thalach", data=df, ax= ax[1]).set_title("Boxplot Frequência Cardíaca Máxima")

"""**Angina induzida pelo exercício**"""

g = sns.catplot(data=df, x="exang", y="target", kind="bar")
g.fig.suptitle("Angina induzida pelo exercício pela presença ou não de doença cardíaca",  y=1.05)
g.fig.set_size_inches(7, 5)
plt.show()

"""**Depressão do ST induzida pelo exercício em relação ao estado de repouso**"""

fig, ax =plt.subplots(1,2)
sns.set(rc={'figure.figsize':(11.7,8.27)})
sns.histplot(data=df, x="oldpeak", element="step", ax = ax[0]).set_title("Histograma Depressão do DS")
sns.boxplot( y="oldpeak", data=df, ax= ax[1]).set_title("Boxplot Depressão do DS")

"""**Segmento ST medido em termos de inclinação durante o pico do exercício**"""

g= sns.catplot(data=df, x="slope", y="target", kind="bar")
g.fig.suptitle("Segmento ST pela presença ou não de doença cardíaca",  y=1.05)
g.fig.set_size_inches(7, 5)
plt.show()

"""**O número de vasos principais (0–3)**"""

fig, ax =plt.subplots(1,2)
sns.set(rc={'figure.figsize':(11.7,8.27)})
sns.histplot(data=df, x="ca", element="step", ax = ax[0]).set_title("Histograma Número de Vasos Principais")
sns.boxplot( y="ca", data=df, ax= ax[1]).set_title("Boxplot Número de Vasos Principais")

"""**Talassemia (distúrbio sanguíneo)**"""

g = sns.catplot(data=df, x="thal", y="target", kind="bar")
g.fig.suptitle("Talassemia pela presença ou não de doença cardíaca",  y=1.05)
g.fig.set_size_inches(7, 5)
plt.show()

"""**Se paciente sofre de doença cardíaca ou não (target)**"""

fig, ax =plt.subplots(1,2)
sns.set(rc={'figure.figsize':(11.7,8.27)})
sns.histplot(data=df, x="target", element="step", ax = ax[0]).set_title("Histograma Variável Alvo")
sns.boxplot( y="target", data=df, ax= ax[1]).set_title("Boxplot Variável Alvo")

"""# <font color=purple size=5> Análise de variaveis categóricas (qualitativas)"""

copy = df.copy()

copy['slope'] = copy['slope'].replace({0: 'inclinação ascendente', 1:'plano', 2:'inclinação descendente' })
copy['target'] = copy['target'].replace({0: 'Sem doença cardíaca', 1:'Com doença cardíaca' })
copy['sex'] = copy['sex'].replace({0: 'Feminino', 1:'Masculino' })
copy['cp'] = copy['cp'].replace({0:'angina tipica', 1: 'angina atipica', 2 :'dor não anginosa',3 :'assintomática'})
copy['fbs'] = copy['fbs'].replace({0:'Falso', 1:'Verdadeiro'})
copy['restecg'] = copy['restecg'].replace({0: 'Normal', 1: 'anormalidade onda ST-T' , 2: 'provável hipertrofia V. E.'})
copy['exang'] = copy['exang'].replace({0:'Não', 1:'Sim'})
copy['slope'] = copy['slope'].replace({0: 'Inclinação ascendente' , 1: 'Plano', 2: 'Inclinação descendente'})
copy['ca'] = copy['ca'].replace({0:'Nenhum', 1:'Um', 2: 'Dois', 3: 'Três'})
copy['thal'] = copy['thal'].replace({0: 'NULO', 1: 'fluxo normal', 2: 'defeito fixo', 3: 'defeito reversível'})

# Plotar o gráfico de barras
ax = sns.countplot(x='slope', hue='target', data=copy)

# Adicione anotações para exibir os valores da coluna
for p in ax.patches:
    ax.annotate(f'{p.get_height():.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', fontsize=11, color='gray', xytext=(0, 8),
                textcoords='offset points')

# Adicionar um título
ax.set_title("Segmento ST vs doença cardíaca")

# Adicionar legendas nos eixos x e y
ax.set_ylabel("Total de indivíduos")
ax.set_xlabel("Categorias de segmento ST")

# Mostrar o gráfico
sns.despine()
ax.legend(loc='upper right', bbox_to_anchor=(1.05, 1))
sns.set(rc={'figure.figsize':(8,6)})

"""### <font color=purple size=5>Gráfico de barras"""

# Plotar o gráfico de barras
ax = sns.countplot(x='sex', hue='target', data=copy)

# Adicione anotações para exibir os valores da coluna
for p in ax.patches:
    ax.annotate(f'{p.get_height():.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', fontsize=11, color='gray', xytext=(0, 8),
                textcoords='offset points')

# Adicionar um título
ax.set_title("Sexo vs doença cardíaca")
ax.set_ylabel("Total de indivíduos")
ax.set_xlabel("Sexo")

# Mostrar o gráfico
sns.despine()
ax.legend(loc='upper right', bbox_to_anchor=(1.05, 1))
sns.set(rc={'figure.figsize':(8,6)})

# Plotar o gráfico de barras
ax = sns.countplot(x='cp', hue='target', data=copy)

# Adicione anotações para exibir os valores da coluna
for p in ax.patches:
    ax.annotate(f'{p.get_height():.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', fontsize=11, color='gray', xytext=(0, 8),
                textcoords='offset points')

# Adicionar um título
ax.set_title("Tipo de dor torácica vs doença cardíaca")
ax.set_ylabel("Total de indivíduos")
ax.set_xlabel("Tipo de dor torácica")

# Mostrar o gráfico
sns.despine()
ax.legend(loc='upper right', bbox_to_anchor=(1.05, 1))
sns.set(rc={'figure.figsize':(8,6)})

# Plotar o gráfico de barras
ax = sns.countplot(x='fbs', hue='target', data=copy)

# Adicione anotações para exibir os valores da coluna
for p in ax.patches:
    ax.annotate(f'{p.get_height():.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', fontsize=11, color='gray', xytext=(0, 8),
                textcoords='offset points')

# Adicionar um título
ax.set_title("Níveis de açúcar no sangue > 120 mg/dl vs doença cardíaca")
ax.set_ylabel("Total de indivíduos")
ax.set_xlabel("Possui nível de açúcar no sangue > 120 mg/dl?")

# Mostrar o gráfico
sns.despine()
ax.legend(loc='upper right', bbox_to_anchor=(1.05, 1))
sns.set(rc={'figure.figsize':(8,6)})

# Plotar o gráfico de barras
ax = sns.countplot(x='restecg', hue='target', data=copy)

# Adicione anotações para exibir os valores da coluna
for p in ax.patches:
    ax.annotate(f'{p.get_height():.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', fontsize=11, color='gray', xytext=(0, 8),
                textcoords='offset points')

# Adicionar um título
ax.set_title("Resultado do eletrocardiograma vs doença cardíaca")
ax.set_ylabel("Total de indivíduos")
ax.set_xlabel("Resultado do eletrocardiograma")

# Mostrar o gráfico
sns.despine()
ax.legend(loc='upper right', bbox_to_anchor=(1.05, 1))
sns.set(rc={'figure.figsize':(8,6)})

# Plotar o gráfico de barras
ax = sns.countplot(x='exang', hue='target', data=copy)

# Adicione anotações para exibir os valores da coluna
for p in ax.patches:
    ax.annotate(f'{p.get_height():.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', fontsize=11, color='gray', xytext=(0, 8),
                textcoords='offset points')

# Adicionar um título
ax.set_title(" Angina induzida por exercício vs doença cardíaca")
ax.set_ylabel("Total de indivíduos")
ax.set_xlabel("Presença de angina induzida por exercício?")

# Mostrar o gráfico
sns.despine()
ax.legend(loc='upper right', bbox_to_anchor=(1.05, 1))
sns.set(rc={'figure.figsize':(8,6)})

# Plotar o gráfico de barras
ax = sns.countplot(x='ca', hue='target', data=copy)

# Adicione anotações para exibir os valores da coluna
for p in ax.patches:
    ax.annotate(f'{p.get_height():.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', fontsize=11, color='gray', xytext=(0, 8),
                textcoords='offset points')

# Adicionar um título
ax.set_title("N de vasos principais vs doença cardíaca")
ax.set_ylabel("Total de indivíduos")
ax.set_xlabel("N de vasos principais")

# Mostrar o gráfico
sns.despine()
ax.legend(loc='upper right', bbox_to_anchor=(1.05, 1))
sns.set(rc={'figure.figsize':(8,6)})

# Plotar o gráfico de barras
ax = sns.countplot(x='thal', hue='target', data=copy)

# Adicione anotações para exibir os valores da coluna
for p in ax.patches:
    ax.annotate(f'{p.get_height():.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', fontsize=11, color='gray', xytext=(0, 8),
                textcoords='offset points')

# Adicionar um título
ax.set_title("presença de Talassemia vs doença cardíaca")
ax.set_ylabel("Total de indivíduos")
ax.set_xlabel("Talassemia")

# Mostrar o gráfico
sns.despine()
ax.legend(loc='upper right', bbox_to_anchor=(1.05, 1))
sns.set(rc={'figure.figsize':(8,6)})

"""### <font color=purple size=5>Teste qui quadrado

O teste qui-quadrado dentre outras finalidades, pode ser utilizado para avaliar a associação entre duas variáveis qualitativas nominais X e Y. 
As hipóteses desse teste são:
* H0:  p-value > 0,05. Não há associação entre as variáveis.
(casualidade).


* H1: p-value < 0,05. Há associação entre as variáveis. Os grupos estão associados.

* OBS: 
** Se houver ocorrência de algum zero na tabela de contingência dos dados observados, é necessário usar o teste de Fisher, e não o de qui quadrado
** Se 20% ou mais da frequência esperada for menor que 5, é utilizado o teste de Fisher
"""

from scipy.stats import chi2_contingency

"""**Sexo vs target**"""

tabela_var_vs_target = pd.crosstab(index = df['sex'],columns=df['target'])
chi, p, dof, array = chi2_contingency(tabela_var_vs_target) 
print(f'p-value = {p:.4}')

"""**Tipo de dor torácica sentida pelo paciente vs Target**"""

tabela_var_vs_target = pd.crosstab(index = df['cp'],columns=df['target'])
chi, p, dof, array = chi2_contingency(tabela_var_vs_target) 
print(f'p-value = {p:.4}')

"""**Níveis de açúcar no sangue**"""

tabela_var_vs_target = pd.crosstab(index = df['fbs'],columns=df['target'])
chi, p, dof, array = chi2_contingency(tabela_var_vs_target) 
print(f'p-value = {p:.4}')

"""**Resultado do eletrocardiograma vs Target:**"""

tabela_var_vs_target = pd.crosstab(index = df['restecg'],columns=df['target'])
chi, p, dof, array = chi2_contingency(tabela_var_vs_target) #Essa
print(f'p-value = {p:.4}')

"""**Angina induzida pelo exercício vs Target:**"""

tabela_var_vs_target = pd.crosstab(index = df['exang'],columns=df['target'])
chi, p, dof, array = chi2_contingency(tabela_var_vs_target) 
print(f'p-value = {p:.4}')

"""**Segmento ST medido em termos de inclinação durante o pico do exercício vs Target:**"""

tabela_var_vs_target = pd.crosstab(index = df['slope'],columns=df['target'])
chi, p, dof, array = chi2_contingency(tabela_var_vs_target) 
print(f'p-value = {p:.4}')

"""**Número de vasos principais vs Target:**"""

tabela_var_vs_target = pd.crosstab(index = df['ca'],columns=df['target'])
chi, p, dof, array = chi2_contingency(tabela_var_vs_target) 
print(f'p-value = {p:.4}')

"""**Talassemia (tipo de anemia) vs Target**"""

tabela_var_vs_target = pd.crosstab(index = df['thal'],columns=df['target'])
chi, p, dof, array = chi2_contingency(tabela_var_vs_target) 
print(f'p-value = {p:.4}')

"""### Resultado da análise qualitativa

De acordo com a análise exploratória dos dados qualitativos e os resultados do teste de Qui-quadrado, podemos considerar que as variáveis mais associadas são 'thal', 'cp', 'ca', 'slope', 'restecg', 'exang' e 'sex', possui resultado significativo para a presença de associação com a variável Target.

# <font color=purple size=5>Análise de variaveis numéricas (quantitativas)
"""

numericas = df.drop(columns=['sex','cp','fbs','restecg','exang','slope','ca','thal', 'target'])

"""**Análise da correlação entre as variáveis**"""

corr = numericas.corr()
corr.style.background_gradient(cmap='coolwarm')

"""**Análise de distribuição das variáveis quantitaivas numéricas**"""

fig, axs = plt.subplots(nrows=2, ncols=3, figsize=(18, 12))
sns.set_style('darkgrid')

# Define a paleta de cores
sns.set_palette('husl')

# Plotando os histogramas em cada subplot
sns.histplot(ax=axs[0,0], data=numericas['age'], kde=False)
sns.histplot(ax=axs[0,1], data=numericas['trestbps'], kde=False)
sns.histplot(ax=axs[0,2], data=numericas['chol'], kde=False)
sns.histplot(ax=axs[1,0], data=numericas['thalach'], kde=False)
sns.histplot(ax=axs[1,1], data=numericas['oldpeak'], kde=False)

# Definindo o título de cada subplot
axs[0,0].set_title('Histograma da idade do paciente (anos)')
axs[0,1].set_title('Histograma do nível de pressão arterial (mm/HG)')
axs[0,2].set_title('Histograma do colesterol sérico em (mg/dl)')
axs[1,0].set_title('Histograma da frequência cardíaca máxima')
axs[1,1].set_title('Histograma da depressão do ST induzida pelo exercício')

axs[0,0].set_ylabel('Total')
axs[0,1].set_ylabel('Total')
axs[0,2].set_ylabel('Total')
axs[1,0].set_ylabel('Total')
axs[1,1].set_ylabel('Total')

# Exibindo o gráfico
plt.show()

"""## <font color=purple size=5>**Teste de hipóstese T-Student**

O teste T-student é utilizado para verificar se existe diferença significativa entre as médias de duas amostras independentes.


Definidas as hipóteses nula e alternativa:


*   H0: p > a. As médias das duas amostras são iguais.

* Ha: p > a. As médias das duas amostras são diferentes.

E o nível de significância α = 0.05



"""

copy =  df.copy()
copy['target'] = copy['target'].replace({0: 'Não', 1:'Sim' })

def compare_variable(column, ylabel, title):
  # Crie o gráfico de boxplot
  ax = sns.boxplot(x='target', y=column, data=copy, linewidth=1.5, palette="Blues")

  # Defina o título do gráfico
  ax.set_title(title)

  # Defina as legendas dos eixos x e y
  ax.set_xlabel("Possui doença cardíaca")
  ax.set_ylabel(ylabel)

  # Exiba o gráfico
  sns.despine(left=True)
  plt.show()

  grupo1 = copy[copy['target'] == 'Sim'][column]
  grupo2 = copy[copy['target'] == 'Não'][column]

  resultado = ttest_ind(grupo1, grupo2)

  print('As médias entre as variáveis são significativamente diferentes? ')
  if resultado.pvalue < 0.05:
    print('Sim')
  else:
    print('Não')

compare_variable(column='chol', ylabel="Nível de colesterol (mg/dl)", title="Colesterol sérico em mg/dl por pessoas com doença cardíaca")

compare_variable(column='age', ylabel="Idade dos indivíduos", title="Idade por pessoas com doença cardíaca")

compare_variable(column='trestbps', ylabel="Nível de pressão arterial em repouso (mm/HG)", title="Nível de pressão arterial por pessoas com doença cardíaca")

compare_variable(column='thalach', ylabel="Frequência cardíaca máxima", title="Frequência cardíaca máxima por pessoas com doença cardíaca")

compare_variable(column='oldpeak', ylabel="Depressão do ST", title="Depressão do ST por pessoas com doença cardíaca")

"""### <font color=purple size=5> Resultado da análise das variáveis quantitativas

De acordo com a análise exploratória dos dados quantitativos e os resultados do teste de T-Student, podemos considerar que as variáveis mais associadas são 'age', 'oldpeak', 'trestbps' e 'thalach', possui uma diferença significativa entre a média com a variável Target.

# <font color=purple size=5>Modelo de regressão logística

**Transformação em dummys**
"""

dados_dummies = pd.get_dummies(df, columns=['cp', 'ca', 'thal', 'sex', 'restecg', 'exang', 'slope'], drop_first=True)
dados = dados_dummies.drop(columns=['chol','fbs'])
dados.head()

"""**Separando em dados X (variáveis independentes) e y (target ou variável dependente)**"""

y = dados['target']
x = dados.drop(columns = 'target')

""" **Printando os valores das variáveis independentes X (formato de matriz)**"""

x

""" **Printando os valores da variável dependente y (formato de vetor)**"""

y

"""**Dividindo os dados em treinamento e testes**

"""

SEED = 77
treino_x, teste_x, treino_y, teste_y = train_test_split(x, y, test_size = 0.30, random_state = SEED)

"""**Verificando o tamanho das bases de treino e de teste**"""

base_treino = treino_x.shape[0]
base_teste = teste_x.shape[0]
print('A base de teste de treino tem %s elementos e a base de teste tem %s elementos.' %(base_treino, base_teste))

"""**Aplicando o algoritmo de regressão logística e calculando a acurácia de treino**"""

modelo = LogisticRegression(max_iter=1000)
modelo.fit(treino_x, treino_y)
round(modelo.score(treino_x, treino_y), 3)*100

"""**Exibindo a tabela resumo**"""

reg_log = sm.Logit(treino_y, treino_x).fit()
print(reg_log.summary())

"""*Ao excluir as variáveis sem relevância (p>0,05), observadas na tabela resumo, e aplicar o algoritmo de regressão logística, novamente, houve uma redução na acurácia de teste, além de redução da AOC e piora da matriz de confusão. Sendo assim, optou-se por manter as variáveis.*

**Aplicando o método predict na base de teste**
"""

previsoes = modelo.predict(teste_x)
previsoes

"""**Calculando a acurácia de teste a partir das previsões**

"""

acuracia = accuracy_score(teste_y, previsoes)
acuracia = round(acuracia, 3)*100
acuracia

"""**Aplicando o método score (outra forma de calcular a acurácia)**

"""

round(modelo.score(teste_x, teste_y), 3)*100

"""*Tem-se como resultado a probabilidade de acerto entre os valores previstos e os reais fornecidos*

**Aplicando o método predict_proba**
"""

modelo.predict_proba(teste_x)

"""*Esse método define a probabilidade do paciente sofrer uma doença cardíaca.*

*Exemplo: Para a linha 1, têm-se as seguintes probabilidades de sofrer uma doença cardíaca:*
- A probabilidade de pertencer a classe 0, que significa que o paciente é normal, é de 0.047;
- A probabilidade de pertencer a classe 1, que significa que o paciente sofre de doença cardíaca, é de 0.953.

**Plotando a matriz de confusão**
"""

matriz_confusao = confusion_matrix(teste_y, previsoes)
print(matriz_confusao)

"""**Visualizando a matriz de confusão**

"""

cm = confusion_matrix(teste_y, previsoes)

fig, ax = plt.subplots(figsize=(8, 8))
ax.imshow(cm)
ax.grid(False)
ax.xaxis.set(ticks=(0, 1), ticklabels=('0s Previstos', '1s Previstos'))
ax.yaxis.set(ticks=(0, 1), ticklabels=('0s Reais', '1s Reais'))
ax.set_ylim(1.5, -0.5)
for i in range(2):
    for j in range(2):
        ax.text(j, i, cm[i, j], ha='center', va='center', color='white')
plt.show()

"""*O resultado mostra que foram obtidas 68 (41+27) previsões corretas 13 (11+2) previsões incorretas.*

*A matriz obtida mostra o seguinte:* 
- 41 previsões negativas verdadeiras: As 41 primeiras observações são zeros previstos corretamente;

- 11 previsões negativas falsas: são aquelas previstas erroneamente como zeros;

- 2 previsões positivas falsas: são aquelas previstas erroneamente como um;

- 27 previsões positivas verdadeiras: são aquelas previstas corretamente como um.

**Organizando e compilando as funções derivadas da matriz de confusão**
"""

print(classification_report(teste_y, previsoes))

"""*84% de acurácia: a cada 100 casos, o modelo acerta 84 casos.*

*Precisão: proporção de predições corretas de uma categoria em relação a todas as predições desta categoria.*

*Recall: Proporção de predições corretas de categoria alvo.*

*F1-Score: Média harmônica entre precisão e recall.*

*Support: a quantidade absoluta de casos encontrados em cada categoria.*

**Gráfico de curva ROC**
"""

prob_previsao = modelo.predict_proba(teste_x)[:,1]

#tfp: taxa de falsos positivos
#tvp: taxa de verdadeiros positivos

tfp, tvp, limite = roc_curve(teste_y, prob_previsao)
print('roc_auc', roc_auc_score(teste_y, prob_previsao))

plt.subplots(1, figsize = (5,5))
plt.title ('Curva ROC')
plt.plot(tfp,tvp)
plt.xlabel('Especificidade')
plt.ylabel('Sensibilidade')
plt.plot([0,1], ls="--", c= 'red')

plt.plot([0,0],[1,0], ls="--", c= 'green'), plt.plot([1,1], ls="--", c= 'green')

plt.show()

"""*Linha vermelha: representa um modelo completamente aleatório, onde todas as previsões do modelo não seguem nenhuma tendência de dados / regra;*

*Linha verde: indica um modelo perfeito, onde todas as predições estão corretas;*

*AUC: área sob a curva ROC; quantifica a curva ROC, ou seja, através da área sob a curva, avalia o resultado do gráfico.*

*Convenção Estatística:*

- área < 0,7: baixa discriminação;
- 0,7 ≤ área < 0,8: discriminação aceitável;
- 0,8 ≤ área < 0,9: discriminação excelente;
- área > 0,9: discriminação excepcional.

AUC = 0,915 -> o modelo gerou uma **discriminação excepcional.**

# <font color=purple size=5>**CONCLUSÃO**

# <font color=purple size=5> **As 5 principais "causas" de doenças cardíacas**


# <font color=purple size=4> Considerando o impacto das variáveis sobre a causalidade com as doenças cardíacas, foram observadas aquelas que possuíam p-valor menor que 0,05. A primeira variável mais significativa é a existência de 2 vasos principais, que tem efeito positivo, ou seja, mais provável de possuir doenças cardíacas, seguido de 1 e 3 vasos principais, também diretamente proporcionais. A próxima variável mais importante diz respeito à dor torácica, especificamente a classificada como assintomática, influenciando o resultado final de forma direta, com inclinação de 1,784. Por fim, a talassemia ㅡ que é uma uma doença hereditária que pode se manifestar de formas diferentes e tem sintomas como palidez, icterícia, atraso no crescimento ㅡ impacta diretamente no modelo de doenças cardíacas, mas na condição de reversível.
"""